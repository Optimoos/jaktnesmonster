import cart { Mirroring }

class RGB {
    public red: u8
    public green: u8
    public blue: u8

    public fn to_u32(this) -> u32 {
    // Order is RGBA for SDL
        return (255 << 24u32) | (.blue << 16) | (.green << 8) | .red 
    }
}

class Sprite {
    public hflip: bool
    public mask: [u8]
    public bg_sprite: bool
    public sprite_x: u8
    public sprite_zero: bool

    public fn get_sprite_pixel(this, x: u8) -> (bool, u8){
        //TODO (?): How did the hardware handle this with 8 bits?
        guard x >= .sprite_x and (x as! u16) < ((.sprite_x as! u16) + 8u16) else {
            return(false, 0u8)
        }

        mut shift_amount = match .hflip {
            true => (x - .sprite_x) as! i16
            else => 7 - (x as! i16 - .sprite_x as! i16)
        }

        if (shift_amount < 0) {
            shift_amount = 0
        }

        let entry = .mask[shift_amount as! u8]

        return (true, entry)
    }
}

class OAMMemory {
    m_y_position: [u8]
    m_tile_index: [u8]
    m_attribute: [u8]
    m_x_position: [u8]
    public m_sprite_zero: [bool]
    public fn init(anon size: u8 = 255u8) throws -> OAMMemory {
        return OAMMemory(m_y_position:[0u8;size], m_tile_index:[0u8;size], m_attribute:[0u8;size], m_x_position:[0u8;size], m_sprite_zero: [false;size])
    }
    
    public fn read(this, address: u8) -> u8 {
        mut result: u8 = 0u8
        let index = address >> 2
        match address % 4 {
            (0) => { result = .m_y_position[index] }
            (1) => { result = .m_tile_index[index] }
            (2) => { result = .m_attribute[index] }
            (3) => { result = .m_x_position[index] }
            else => {}
        }
        return result
    }

    public fn write(mut this, address: u8, value: u8) {
        // eprintln("OAM write - addr: {}, value: {}", address, value)
        let index = address >> 2
        match address % 4 {
            (0) => { .m_y_position[index] = value }
            (1) => { .m_tile_index[index] = value }
            (2) => { .m_attribute[index] = value }
            (3) => { .m_x_position[index] = value }
            else => { eprintln("Bad news bears!")}
        }
    }

    // These gets and sets may be unnecessary, if there's nothing complex about
    // the interactions required to be kept in internal functions, make the 
    // variables public

    public fn y_position(this, address: u8) -> u8 {
        return .m_y_position[address >> 2]
    }

    public fn set_y_position(mut this, address: u8, value: u8) {
        .m_y_position[address >> 2] = value
    }

    public fn tile_index(this, address: u8) -> u8 {
        return .m_tile_index[address >> 2]
    }

    public fn set_tile_index(mut this, address: u8, value: u8) {
        .m_tile_index[address >> 2] = value
    }

    public fn attribute(this, address: u8) -> u8 {
        return .m_attribute[address >> 2]
    }

    public fn set_attribute(mut this, address: u8, value: u8) {
        .m_attribute[address >> 2] = value
    }

    public fn x_position(this, address: u8) -> u8 {
        return .m_x_position[address >> 2]
    }

    public fn set_x_position(mut this, address: u8, value: u8) {
        .m_x_position[address >> 2] = value
    }

    public fn v_flipped(this, address: u8) -> bool {
        return (.m_attribute[address >> 2] & 0b10000000) == 0b10000000
    }

    public fn h_flipped(this, address: u8) -> bool {
        return (.m_attribute[address >> 2] & 0b01000000) == 0b01000000
    }

}

class PPU {
    // base_table_address: u16
    vram_address_increment: u16
    sprite_table_address: u16
    background_table_address: u16
    sprite_size_8x8: bool
    public nmi_on_vblank: bool
    clock: u64
    public in_vblank: bool
    dont_vblank: bool
    public nametable_data: [[u8]]
    public nametables: [usize]
    public palette: [u8]
    // public vram_rw_addr: u16
    oam_addr: u8
    // public oam: [u8]
    // second_oam: [Sprite]
    public oam: OAMMemory
    oam_secondary: OAMMemory
    public chr_rom_pages: [[u8]]
    public chr_rom_page_0000: usize
    public chr_rom_page_1000: usize
    public video_buffer: [u32]
    // scroll_x: u8
    // scroll_y: u8
    // scroll_toggle: bool
    background_visible: bool
    sprites_visible: bool
    buffered_read: u8
    sprite_zero_hit: bool
    sprite_overflow: bool
    public debug: bool
    rendering_enabled: bool
    public even_frame_flag: bool

    left_sprite_mask: bool
    left_bg_mask: bool

    horizontal_pixel: u64
    vertical_pixel: u64
    dma_ticks: u64
    public mapper: u8
    public mmc3_chr_a12_inversion: usize
    public mmc3_chr_rom_2k_bank_0: usize
    public mmc3_chr_rom_2k_bank_1: usize
    public mmc3_chr_rom_1k_bank_0: usize
    public mmc3_chr_rom_1k_bank_1: usize
    public mmc3_chr_rom_1k_bank_2: usize
    public mmc3_chr_rom_1k_bank_3: usize
    public mmc3_irq_counter: u8
    public mmc3_irq_counter_reload: u8
    public mmc3_irq_enabled: bool
    public mmc3_irq_flag: bool
    public mmc3_irq_reload_flag: bool

    // Internal PPU registers (from https://www.nesdev.org/wiki/PPU_scrolling)
    v: u16
    t: u16
    x: u16      // x and w are 8 bits on original hardware, we use u16 to avoid conversion issues
    w: u16

    color_palette: [u32]

    transparent_draws: u64
    solid_draws: u64

    public fn init(chr_rom_pages: [[u8]], mapper: u8) throws -> PPU {
        mut video_buffer: [u32] = [rgb(0,0,0); 256*240]
        return PPU(
            vram_address_increment: 1
            sprite_table_address: 0x0000
            background_table_address: 0x0000
            sprite_size_8x8: true
            nmi_on_vblank: false
            clock: 0
            in_vblank: false
            dont_vblank: false
            nametable_data: [[0x0; 0x400], [0x0; 0x400], [0x0; 0x400], [0x0; 0x400]]
            nametables: [0; 4]
            palette: [0x0; 32]
            oam_addr: 0x00
            // oam: [0xff; 256]
            // second_oam: []
            oam: OAMMemory::init(size: 64)
            oam_secondary: OAMMemory::init(size: 8)
            chr_rom_pages
            chr_rom_page_0000: 0
            chr_rom_page_1000: chr_rom_pages.size() - 1
            video_buffer
            background_visible: false
            sprites_visible: false
            buffered_read: 0
            sprite_zero_hit: false
            sprite_overflow: false
            debug: false
            rendering_enabled: false
            even_frame_flag: true
            left_sprite_mask: false
            left_bg_mask: false
            horizontal_pixel: 0
            vertical_pixel: 0
            dma_ticks: 0
            mapper
            mmc3_chr_a12_inversion: 0
            mmc3_chr_rom_2k_bank_0: 0
            mmc3_chr_rom_2k_bank_1: 0
            mmc3_chr_rom_1k_bank_0: 0
            mmc3_chr_rom_1k_bank_1: 0
            mmc3_chr_rom_1k_bank_2: 0
            mmc3_chr_rom_1k_bank_3: 0
            mmc3_irq_counter: 0
            mmc3_irq_counter_reload: 0
            mmc3_irq_enabled: false
            mmc3_irq_flag: false
            mmc3_irq_reload_flag: false
            

            // internal PPU registers
            v: 0
            t: 0
            x: 0
            w: 0

            color_palette: [
                    rgb(101 101 101)
                    rgb(0    45 105)
                    rgb(19   31 127)
                    rgb(69   19 124)
                    rgb(96   11  98)
                    rgb(115  10  55)
                    rgb(113  15   7)
                    rgb(90   26   0)
                    rgb(52   40   0)
                    rgb(11   52   0)
                    rgb(0   60    0)    
                    rgb(0   61   16)    
                    rgb(0   56   64)
                    rgb(0    0    0)
                    rgb(0    0    0)
                    rgb(0    0    0)
                    rgb(174 174 174)
                    rgb(15   99 179)
                    rgb(64   81 208)
                    rgb(120  65 204)
                    rgb(167  54 169)
                    rgb(192  52 112)
                    rgb(189  60  48)
                    rgb(159  74   0)
                    rgb(109  92   0)
                    rgb(54  109   0)
                    rgb(7   119   4)
                    rgb(0   121  61)
                    rgb(0   114 125)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(254 254 255)
                    rgb(93  179 255)
                    rgb(143 161 255)
                    rgb(200 144 255)
                    rgb(247 133 250)
                    rgb(255 131 192)
                    rgb(255 139 127)
                    rgb(239 154  73)
                    rgb(189 172  44)
                    rgb(133 188  47)
                    rgb(85  199  83)    
                    rgb(60  201 140)    
                    rgb(62  194 205)
                    rgb(78   78  78)
                    rgb(0     0   0)
                    rgb(0     0   0)
                    rgb(254 254 255)
                    rgb(188 223 255)
                    rgb(209 216 255)
                    rgb(232 209 255)
                    rgb(251 205 253)
                    rgb(255 204 229)
                    rgb(255 207 202)
                    rgb(248 213 180)
                    rgb(228 220 168)
                    rgb(204 227 169)
                    rgb(185 232 184)    
                    rgb(174 232 208)    
                    rgb(175 229 234)
                    rgb(182 182 182)
                    rgb(0    0    0)
                    rgb(0    0    0)
                ]   

                transparent_draws: 0
                solid_draws: 0
        )
    }

    public fn mmc3_clock_irq(mut this) {
        if .mmc3_irq_counter == 0 or .mmc3_irq_reload_flag {
            .mmc3_irq_counter = .mmc3_irq_counter_reload;
            .mmc3_irq_reload_flag = false;
        } else {
            .mmc3_irq_counter--
        }

        if .mmc3_irq_counter == 0 {
            .mmc3_irq_flag = .mmc3_irq_enabled;
        }
    }

    public fn mmc3_chr_rom_byte_at(mut this, page: usize, index: u16) -> u8 {
        mut computed_address: u16 = 0x0
        if page == .chr_rom_page_1000 {
            computed_address += 0x1000
        }
        computed_address += index
        mut computed_page: usize = 0
        mut computed_index: u16 = 0
        mut selected_bank: usize = 0
        mut offset: u16 = 0
        if .mmc3_chr_a12_inversion == 0 {
            match computed_address {
                0x0000u16..0x0800u16 => {
                    // 2 KB CHR bank at PPU $0000-$07FF
                    selected_bank = .mmc3_chr_rom_2k_bank_0
                    offset = 0x0000
                }
                0x0800u16..0x1000u16 => {
                    // 2 KB CHR bank at PPU $0800-$0FFF
                    selected_bank = .mmc3_chr_rom_2k_bank_1
                    offset = 0x0800
                }
                0x1000u16..0x1400u16 => {
                    // 1 KB CHR bank at PPU $1000-$13FF
                    selected_bank = .mmc3_chr_rom_1k_bank_0
                    offset = 0x1000
                }
                0x1400u16..0x1800u16 => {
                    // 1 KB CHR bank at PPU $1400-$17FF
                    selected_bank = .mmc3_chr_rom_1k_bank_1
                    offset = 0x1400
                }
                0x1800u16..0x1c00u16 => {
                    // 1 KB CHR bank at PPU $1800-$1BFF
                    selected_bank = .mmc3_chr_rom_1k_bank_2
                    offset = 0x1800
                }
                0x1c00u16..0x2000u16 => {
                    // 1 KB CHR bank at PPU $1C00-$1FFF
                    selected_bank = .mmc3_chr_rom_1k_bank_3
                    offset = 0x1c00
                }
                else => {
                    return 0
                }
            }
        } else {
            match computed_address {
                0x1000u16..0x1800u16 => {
                    // 2 KB CHR bank at PPU $1000-$17FF
                    selected_bank = .mmc3_chr_rom_2k_bank_0
                    offset = 0x1000
                }
                0x1800u16..0x2000u16 => {
                    // 2 KB CHR bank at PPU $1800-$1FFF
                    selected_bank = .mmc3_chr_rom_2k_bank_1
                    offset = 0x1800
                }
                0x0000u16..0x0400u16 => {
                    // 1 KB CHR bank at PPU $0000-$03FF
                    selected_bank = .mmc3_chr_rom_1k_bank_0
                    offset = 0x0000
                }
                0x0400u16..0x0800u16 => {
                    // 1 KB CHR bank at PPU $0400-$07FF
                    selected_bank = .mmc3_chr_rom_1k_bank_1
                    offset = 0x0400
                }
                0x0800u16..0x0c00u16 => {
                    // 1 KB CHR bank at PPU $0800-$0BFF
                    selected_bank = .mmc3_chr_rom_1k_bank_2
                    offset = 0x0800
                }
                0x0c00u16..0x0000u16 => {
                    // 1 KB CHR bank at PPU $0C00-$0FFF
                    selected_bank = .mmc3_chr_rom_1k_bank_3
                    offset = 0x0c00
                }
                else => {
                    return 0
                }
            }
        }
        computed_page = selected_bank / 4
        computed_index = (selected_bank as! u16 % 4) * 0x0400 + computed_address - offset
        return .chr_rom_pages[computed_page][computed_index]
    }

    public fn chr_rom_byte_at(mut this, anon page: usize, anon index: u16) -> u8 {
        return match .mapper {
            4 => .mmc3_chr_rom_byte_at(page, index)
            else => .chr_rom_pages[page][index]
        }
    }

    public fn dma_tick(mut this) throws {
        if .even_frame_flag {
            .tick(cycles: 513 * 3u64)
        } else {
            .tick(cycles: 514 * 3u64)
        }
    }

    public fn set_mirroring(mut this, anon mirroring: Mirroring) {
        match mirroring {
            Horizontal => {
                .nametables[0] = 0
                .nametables[1] = 0
                .nametables[2] = 1
                .nametables[3] = 1
            }
            Vertical => {
                .nametables[0] = 0
                .nametables[1] = 1
                .nametables[2] = 0
                .nametables[3] = 1
            }
            OneScreenLower => {
                .nametables[0] = 0
                .nametables[1] = 0
                .nametables[2] = 0
                .nametables[3] = 0
            }
            OneScreenUpper => {
                .nametables[0] = 1
                .nametables[1] = 1
                .nametables[2] = 1
                .nametables[3] = 1
            }
        }
    }

    public fn tick(mut this, cycles: u64) throws {
        for x in (.clock)..(.clock + cycles) {
            // Where are we on the screen
            .horizontal_pixel = .clock % 341
            .vertical_pixel = .clock / 341

            .render_pixel()
            .clock += 1

            // 257-320 = sprite tile loading interval
            if (.horizontal_pixel == 320) and ((.vertical_pixel >= 0) and (.vertical_pixel <= 239)) {

                // .oam_addr = 0x00
                //.second_oam = .find_sprites(scanline: (.vertical_pixel + 1) as! u8)
                .find_sprites(scanline: (.vertical_pixel + 1) as! u8)
            }
            if (.vertical_pixel == 241) and (.horizontal_pixel == 0) {
                .dont_vblank = false
            }
            // 240 is the post-render line, vblank is set in 241
            if (.vertical_pixel == 241) and (.horizontal_pixel == 1){
                if not .dont_vblank { .in_vblank = true }
            }
            if (.vertical_pixel == 241) and (.horizontal_pixel == 3) {
                .dont_vblank = false
            }

            // FIXME:
            // Debugging - vblank timing needs to be brought up ~32-33 clocks to be correct
            // if (.vertical_pixel == 260) and (.horizontal_pixel == 310) {
            //     .in_vblank = false
            // }

            // 261 is the pre-render line
            if (.vertical_pixel == 261) and (.horizontal_pixel == 1){
                .in_vblank = false
                .sprite_zero_hit = false
                .sprite_overflow = false
            }
            // Coarse X
            // if (.rendering_enabled) and (.horizontal_pixel % 8 == 0) and ((.horizontal_pixel <= 256) or (.horizontal_pixel > 328)) {
            //    .v += 1
            // }
            if (.horizontal_pixel == 339) and (.vertical_pixel == 261) and (.rendering_enabled) and (.even_frame_flag == false) { .clock = 0 }
            if (.horizontal_pixel == 340) and (.vertical_pixel == 261) { .clock = 0 }
            
            .even_frame_flag = not .even_frame_flag
        }
    }

    fn read_nametable(this, anon address: u16) -> u8 {
        match address & 0xfc00 {
            0x2000 => {
                return .nametable_data[.nametables[0]][address & ~0xfc00]
            }
            0x2400 => {
                return .nametable_data[.nametables[1]][address & ~0xfc00]
            }
            0x2800 => {
                return .nametable_data[.nametables[2]][address & ~0xfc00]
            }
            else => {
                return .nametable_data[.nametables[3]][address & ~0xfc00]
            }
        }
    }

    fn write_nametable(mut this, address: u16, value: u8) {
        match address & 0xfc00 {
            0x2000 => {
                .nametable_data[.nametables[0]][address & ~0xfc00] = value
            }
            0x2400 => {
                .nametable_data[.nametables[1]][address & ~0xfc00] = value
            }
            0x2800 => {
                .nametable_data[.nametables[2]][address & ~0xfc00] = value
            }
            else => {
                .nametable_data[.nametables[3]][address & ~0xfc00] = value
            }
        }
    }

    fn render_bg_pixel(mut this) throws -> bool {
        let scroll_x = (.v & 0x1f) * 8 + .x
        let scroll_y = ((.v >> 5) & 0x1f) * 8 + (.v >> 12)

        mut virtual_horizontal_pixel = .horizontal_pixel as! u16 + scroll_x
        mut virtual_vertical_pixel = scroll_y as! u16

        mut base_table = (.v >> 10) & 0x3

        if virtual_horizontal_pixel >= 256 {
            base_table ^= 0x1
            virtual_horizontal_pixel -= 256
        }

        if virtual_vertical_pixel >= 240 {
            base_table ^= 0x2
            virtual_vertical_pixel -= 240
        }

        // Which tile
        let vertical_tile: u16 = virtual_vertical_pixel / 8
        let horizontal_tile: u16 = virtual_horizontal_pixel / 8

        // Fetch nametable entry
        let nametable_entry = .nametable_data[.nametables[base_table]][vertical_tile * 32 + horizontal_tile]
        
        let vertical_attr = vertical_tile / 4
        let horizontal_attr = horizontal_tile / 4

        // 0000
        // ^^^^  
        // | ||
        // | | plane 0
        // | plane 1
        // attr (2 bits)

        let attr = .nametable_data[.nametables[base_table]][0x3c0 + vertical_attr * 8 + horizontal_attr]

        let horizontal_box_pos = (horizontal_tile % 4u16) / 2u16
        let vertical_box_pos = (vertical_tile % 4u16) / 2u16

        let first_plane_entry = nametable_entry as! u16 * 0x10u16 + virtual_vertical_pixel % 8u16
        let second_plane_entry = first_plane_entry + 8u16

        let color_bits = (attr >> ((horizontal_box_pos * 2) + (vertical_box_pos * 4))) & 0x3

        let first_plane_byte = match .background_table_address {
            0000 => .chr_rom_byte_at(.chr_rom_page_0000, first_plane_entry)
            else => .chr_rom_byte_at(.chr_rom_page_1000, first_plane_entry)
        }
        let second_plane_byte = match .background_table_address {
            0000 => .chr_rom_byte_at(.chr_rom_page_0000, second_plane_entry)
            else => .chr_rom_byte_at(.chr_rom_page_1000, second_plane_entry)
        }

        let first_plane_bit = first_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1
        let second_plane_bit = second_plane_byte >> (7 - virtual_horizontal_pixel % 8) & 0x1

        mut has_background_priority = false
        mut rgb = 0u32
        if (first_plane_bit == 0) and (second_plane_bit == 0) {
            rgb = .look_up_palette_entry_bg(palette_entry: 0)
        } else {
            let palette_entry = first_plane_bit + (second_plane_bit * 2) + (color_bits * 4)
            rgb = .look_up_palette_entry_bg(palette_entry)
            has_background_priority = true
        }
        .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
        return has_background_priority
    }

    fn render_sprite_pixel(mut this, bg_set: bool) throws {
        let horizontal_pixel = .horizontal_pixel as! u8
        let vertical_pixel = .vertical_pixel as! u8
        // FIXME: Implement iterator for OAMMemory
        // FIXME: Use known x values of sprites to trigger render rather than blind loops
        //for sprite in .oam_secondary {

        for secondary_oam_index in (0u8..7u8).inclusive() {

            mut clamp_horizontal_pixel: u8 = .oam_secondary.x_position(address: secondary_oam_index * 4)
            if clamp_horizontal_pixel > 247 {
                clamp_horizontal_pixel = 247
            }
            if (horizontal_pixel >= .oam_secondary.x_position(address: secondary_oam_index * 4)) and (horizontal_pixel <= (clamp_horizontal_pixel + 7) and (.oam_secondary.y_position(address: secondary_oam_index * 4) <= 240)) {
                // Sprite can only be output if BG pixel is zero (bg_set==false) or the sprite has foreground priority (5th bit in attributes == 0)
                // However, we cannot filter this early as it will prevent the current sprite 0 mechanism from functioning

                //eprintln("Priority - attr: {:08b}, eval: {}, index: {}, h: {}, v:{}", .oam_secondary.attribute(address: secondary_oam_index * 4), (.oam_secondary.attribute(address: secondary_oam_index * 4) & 0b00100000) != 0b00100000, secondary_oam_index, horizontal_pixel, vertical_pixel )

                                                                                                                // attr: 00100011

                //if (bg_set == false) or ((.oam_secondary.attribute(address: secondary_oam_index * 4) & 0b00100000) != 0b00100000) {

                    if (.oam_secondary.x_position(address: secondary_oam_index) != 255 ) { 
                        //eprintln("Secondary oam entry: x: {}, y: {}, currently x: {}, y: {}", .oam_secondary.x_position(address: secondary_oam_index), .oam_secondary.y_position(address: secondary_oam_index), horizontal_pixel, vertical_pixel)
                        //eprintln("Rendering sprite pixel input h: {}, v: {}, o_x: {} o_y: {}", horizontal_pixel, vertical_pixel, .oam_secondary.x_position(address: secondary_oam_index * 4), .oam_secondary.y_position(address: secondary_oam_index * 4))

                    }

                    //eprintln("Rendering sprite pixel input h: {}, v: {}", horizontal_pixel, vertical_pixel)

                    // Figure out the bit we care about in the chr rom
                    // let current_pixel_mask:u8 = ((vertical_pixel % 8) * 8) + (horizontal_pixel % 8)
                    mut y_difference: u8 = 0
                    if (vertical_pixel >= .oam_secondary.y_position(address: secondary_oam_index * 4)) {
                        y_difference = vertical_pixel - .oam_secondary.y_position(address: secondary_oam_index * 4)
                        //eprintln("Y difference: vertical_pixel: {}, oam y: {}, diff: {}", vertical_pixel,.oam_secondary.y_position(address: secondary_oam_index * 4), y_difference )
                    }
                    mut x_difference: u8 = 0
                    if (horizontal_pixel >=  .oam_secondary.x_position(address: secondary_oam_index * 4)) {
                        x_difference = horizontal_pixel - .oam_secondary.x_position(address: secondary_oam_index * 4)
                        //eprintln("X difference: horizontal_pixel: {}, oam x: {}, diff: {}", horizontal_pixel, .oam_secondary.x_position(address: secondary_oam_index * 4), x_difference )
                    }




                    //eprintln("Difference: {}", current_pixel_mask)

                    //eprintln("OAM sprite location - x: {}, y: {}, pixel count: {}", .oam_secondary.x_position(address: secondary_oam_index), .oam_secondary.y_position(address: secondary_oam_index), current_pixel_mask)


                    // TODO: This can probably be better? What is the object wide .sprite_table_address?
                    // let sprite_base_table = match .sprite_table_address {
                    //     0000 => .chr_rom_page_0000
                    //     else => .chr_rom_page_1000
                    // }

                    // Attribute table to find palette, character rom to get color 
                    // Each pattern table (or CHR) returns 8 bytes. Combined, these provide a 2-bit (4 option) lookup to the palette for the tile, which is selected from the frame palette by a value in the attribute

                    //let sprite_index = (y_difference & 0x7) | ((.oam_secondary.x_position(address: secondary_oam_index * 4) & 0xf) << 4) | ((.oam_secondary.y_position(address: secondary_oam_index * 4) & 0xf) << 8)

                    


                    // eprintln("Old index: {}", sprite_index)
                    // eprintln("Pattern index: {}", .oam_secondary.tile_index(address: secondary_oam_index * 4))

                    // .chr_rom_pages[page][index]

                    // Sprites lookup directly into pattern table (chr) from their tile index
                    // The pattern tables are address from $0000-$0FFF for "left" and $1000-$1FFF for "right".
                    // For 8x8 sprites, left or right is chosen from ppuctrl bit 3
                    // The address format is $<left/right><tile><row>, so a sprite using the left table doing a lookup on tile $69 and row 1
                    // would query $0691 for the first plane, and $0699 for the second plane

                    // Given current setup of our data structures, the left/right selection isn't required


                    // Y difference makes sure we get the correct y bytes for the character, need to handle y flip
                    let sprite_index:u16 = match .oam_secondary.v_flipped(address: secondary_oam_index * 4) {
                        true => (.oam_secondary.tile_index(address: secondary_oam_index * 4) << 4  | 7 - (y_difference)) as! u16
                        else => (.oam_secondary.tile_index(address: secondary_oam_index * 4) << 4  | (y_difference)) as! u16
                    }

                    //eprintln("Y: {}, Sprite Y: {}, Y diff: {}, Tile index: {:04x}, flipped: {}", vertical_pixel, .oam_secondary.y_position(address: secondary_oam_index * 4), y_difference, sprite_index, .oam_secondary.v_flipped(address: secondary_oam_index))

                    let first_plane = .chr_rom_pages[.sprite_table_address][sprite_index]
                    let second_plane = .chr_rom_pages[.sprite_table_address][sprite_index + 8]

                    //let first_plane = .chr_rom_byte_at(page: .sprite_table_address, index: sprite_index as! u16) // FIXME: Can the pattern table data structure be optimized?
                    //let second_plane = .chr_rom_byte_at(page: .sprite_table_address, index: sprite_index as! u16 + 8)

                    //eprintln("Pattern table - first: {:08b}, second: {:08b}, x difference: {}", first_plane, second_plane, x_difference)

                    // Indexes into palette lookup should be formed as follows:
                    // 43210
                    // |||||
                    // |||++- Pixel value from tile data
                    // |++--- Palette number from attribute table or OAM
                    // +----- Background/Sprite select


                    mut shift_amount = match .oam_secondary.h_flipped(address: secondary_oam_index * 4) {
                        true => (x_difference as! i16)
                        else => 7 - (x_difference as! i16)
                    }

                    if (shift_amount < 0) {
                        shift_amount = 0
                    }

                    let palette_lookup: u8 = (.oam_secondary.attribute(address: secondary_oam_index * 4) & 0b00000011)
                    let first_plane_mask: u8 = ((first_plane >> shift_amount) & 0b00000001 )
                    let second_plane_mask: u8 = (second_plane >> shift_amount) & 0b00000001 

                    // All sprites are in the second half of the palette table, organize the above values and mask with 0b00010000
                    let mask: u8 = 0b00010000 | palette_lookup << 2 |  first_plane_mask | second_plane_mask << 1

                    
                    //eprintln("Calculated masks - first {:08b} mask {:05b}, second {:08b} mask {:05b}, palette {:0b}, combined {:05b}, attr: {:08b}, diff: {}, shift: {}, x: {}, y: {}, X flip: {}", first_plane, first_plane_mask, second_plane, second_plane_mask, palette_lookup, mask, .oam_secondary.attribute(address: secondary_oam_index * 4), x_difference, shift_amount, horizontal_pixel, vertical_pixel, .oam_secondary.h_flipped(address: secondary_oam_index * 4))

                    // guard x >= .sprite_x and (x as! u16) < ((.sprite_x as! u16) + 8u16) else {
                    //     return(false, 0u8)
                    // }

                    // mut shift_amount = match .oam_secondary.h_flipped(address: secondary_oam_index) {
                    //     true => (x_difference - .oam_secondary.x_position(address: secondary_oam_index * 4)) as! i16
                    //     else => 7 - (x_difference as! i16 - .oam_secondary.x_position(address: secondary_oam_index * 4) as! i16)
                    // }

                    // if (shift_amount < 0) {
                    //     shift_amount = 0
                    // }

                    //let entry = .mask[shift_amount as! u8]


                    // let render_y:u32 = (.oam_secondary.y_position(address: secondary_oam_index * 4) + y_difference) as! u32
                    // mut render_x:u32 = (.oam_secondary.x_position(address: secondary_oam_index * 4) as! u32) + x_difference as! u32
                    // let render_location:u32 = (render_y * 256) + render_x


                    // Check for transparent (zero) pixel 
                    // FIXME: Move this test earlier                   
                    if (mask & 0b11) != 0 {


                        // FIXME: This is currently only accounting for 8x8 sprites
                        //let rgb = .look_up_palette_entry(palette_entry: (mask))
                        //eprintln("Pattern table - first: {:08b} {:b}, second: {:08b} {:b}, x difference: {}, mask: {:08b} DID H:{} R_X:{} V:{} R_Y:{} R_LOC:{} O_X:{} O_Y:{}, {:08b}", first_plane, first_plane_mask, second_plane, second_plane_mask, x_difference, mask, horizontal_pixel, render_x, vertical_pixel, render_y, render_location, .oam_secondary.x_position(address: secondary_oam_index * 4), .oam_secondary.y_position(address: secondary_oam_index * 4), .oam_secondary.attribute(address: secondary_oam_index * 4))

                        // Works
                        let rgb = .color_palette_to_rgb(.palette[mask])
                        //eprintln("Got color for {:x}, rgb: {:08x}", mask, rgb)
                        //let rgb = 0xffffffffu32
                        //eprintln("Rendering sprite pixel {:x} at x: {}, y: {} (combined: {})", rgb, render_x, render_y, render_location)

                        if not .sprite_zero_hit and horizontal_pixel != 255 {
                            
                            .sprite_zero_hit = (not .sprite_zero_hit) and .oam_secondary.m_sprite_zero[secondary_oam_index]
                            //eprintln("Sprite 0 hit: h:{} o:{} b:{}",.sprite_zero_hit, .oam_secondary.m_sprite_zero[secondary_oam_index], bg_set )
                        } 

                        
                        if (bg_set == false) or ((.oam_secondary.attribute(address: secondary_oam_index * 4) & 0b00100000) != 0b00100000) {
                            .video_buffer[(vertical_pixel as! u32 * 256) + horizontal_pixel as! u32] = rgb 
                        }

                        //.solid_draws += 1
                        //eprintln("T: {} S: {}", .transparent_draws, .solid_draws)                    
                        // Can we get away with escaping from the loop here?
                        // break;
                    } else {
                        //eprintln("Pattern table - first: {:08b} {:b}, second: {:08b} {:b}, x difference: {}, mask: {:08b} DIDN'T H:{} R_X:{} V:{} R_Y:{} O_X:{} O_Y:{}, {:08b}", first_plane, first_plane_mask, second_plane, second_plane_mask, x_difference, mask, horizontal_pixel, render_x, vertical_pixel, render_y, .oam_secondary.x_position(address: secondary_oam_index * 4), .oam_secondary.y_position(address: secondary_oam_index * 4), .oam_secondary.attribute(address: secondary_oam_index * 4))
                        //.transparent_draws += 1
                        //eprintln("T: {} S: {}", .transparent_draws, .solid_draws)
                    }

                //}
            }
        }

        // mut sprite_height = 8u8
        // if not .sprite_size_8x8 {
        //     sprite_height = 16u8
        // }


        //mut sprite_table = sprite_base_table 

        // mut counter = 0u8
        // loop {
        //     if counter == 8 {
        //         break
        //     }

            // if not .sprite_size_8x8 {
            //     if (.oam_secondary.tile_index(address: counter) & 0x1) == 0x1 {
            //         sprite_table = .chr_rom_page_1000
            //     } else {
            //         sprite_table = .chr_rom_page_0000
            //     }
            // } else {
            //     sprite_table = sprite_base_table
            // }

            // let vflip = (.oam_secondary.attribute(address: counter) & 0b10000000) == 0b10000000
            // let tile_row = match vflip {
            //     false => .oam_secondary.y_position(address: counter) // Removed scanline counter from this and line below, that may mess with things
            //     else => sprite_height - 1 - .oam_secondary.y_position(address: counter)
            // }

            // let sprite_index = .oam_secondary.tile_index(address: counter) as! u16 // * 0x10 + tile_row as! u16 //FIXME: third read of tile index
            // let first_plane = .chr_rom_byte_at(sprite_table, sprite_index)
            // let second_plane = .chr_rom_byte_at(sprite_table, sprite_index + 8)

            // mut mask = [0u8; 8]
            // for i in 0..8u8 {
            //     //mask[i] = ((first_plane >> i) & 0x1) | (((second_plane >> i & 0x1) << 1)) | ((.oam_secondary.attribute(address: counter) & 0x3) << 2)
            // }

            // x is the current dot we're rendering
            // mut shift_amount = match (.oam_secondary.attribute(address: counter) & 0x40) == 0x40 {
            //     true => (horizontal_pixel - .oam_secondary.x_position(address: counter)) as! i16
            //     else => 7 - (horizontal_pixel as! i16 - .oam_secondary.x_position(address: counter) as! i16)
            // }

            // if (shift_amount < 0) { 
            //     shift_amount = 0
            // }

            //let entry = mask[shift_amount as! u8]
            // let entry = .oam_secondary.attribute(address:counter) & 0b00000011
            // let transparent = (entry & 0x3) == 0

            // if not transparent {

            //     if not ((.oam_secondary.attribute(address: counter) & 0x20) == 0x20) or not bg_set {
            //         let rgb = .look_up_palette_entry_sprite(palette_entry: entry)
            //         //.video_buffer[vertical_pixel as! u16 * 256u16 + horizontal_pixel as! u16] = rgb
            //     }

            //     // FIXME: This depends on data that isn't available in this function
            //     // Sprite zero can be hit from the background too!
            //     // if not .sprite_zero_hit and .horizontal_pixel != 255 {
            //     //     .sprite_zero_hit = (not .sprite_zero_hit) and sprite.sprite_zero and bg_set
            //     // }
            // }

        //     counter++
        // }
    }

    fn coarse_x_increment(mut this) {
        // if ((v & 0x001F) == 31) // if coarse X == 31
        //     v &= ~0x001F          // coarse X = 0
        //     v ^= 0x0400           // switch horizontal nametable
        // else
        //     v += 1                // increment coarse X

        if (.v & 0x001f) == 31 {
            .v &= ~0x001fu16
            .v ^= 0x400
        } else {
            .v += 1
        }
    }

    fn y_increment(mut this) {
        // if ((v & 0x7000) != 0x7000)        // if fine Y < 7
        //   v += 0x1000                      // increment fine Y
        // else
        //   v &= ~0x7000                     // fine Y = 0
        //   int y = (v & 0x03E0) >> 5        // let y = coarse Y
        //   if (y == 29)
        //     y = 0                          // coarse Y = 0
        //     v ^= 0x0800                    // switch vertical nametable
        //   else if (y == 31)
        //     y = 0                          // coarse Y = 0, nametable not switched
        //   else
        //     y += 1                         // increment coarse Y
        //   v = (v & ~0x03E0) | (y << 5)     // put coarse Y back into v

        if (.mapper == 4) {
            .mmc3_clock_irq()
        }

        if (.v & 0x7000) != 0x7000 {
            .v += 0x1000
        } else {
            .v &= ~0x7000u16
            mut y = (.v & 0x3e0) >> 5
            if y == 29 {
                y = 0
                .v ^= 0x800
            } else if y == 31 {
                y = 0
            } else {
                y += 1
            }
            .v = (.v & ~0x03e0u16) | (y << 5)
        }
    }

    // FIXME: rename to sprite evaluation (assuming that is all this does)

// Each scanline, the PPU reads the spritelist (that is, Object Attribute Memory) to see which to draw:

//     First, it clears the list of sprites to draw.
//     Second, it reads through OAM, checking which sprites will be on this scanline. It chooses the first eight it finds that do.
//     Third, if eight sprites were found, it checks (in a wrongly-implemented fashion) for further sprites on the scanline to see if the sprite overflow flag should be set.
//     Fourth, using the details for the eight (or fewer) sprites chosen, it determines which pixels each has on the scanline and where to draw them

    fn find_sprites(mut this, scanline: u8) throws {
        //mut result: [Sprite] = []
        mut sprite_count = 0u8

        // let sprite_base_table = match .sprite_table_address {
        //     0000 => .chr_rom_page_0000
        //     else => .chr_rom_page_1000
        // }
        // mut sprite_table = sprite_base_table        

        mut sprite_height = 8u8
        if not .sprite_size_8x8 {
            sprite_height = 16u8
        }

        // Reset secondary oam
        for secondary_oam_index in (0u8..7u8).inclusive() {
            .oam_secondary.set_attribute(address: secondary_oam_index * 4, value: 0xFF)
            .oam_secondary.set_y_position(address: secondary_oam_index * 4, value: 0xFF)
            .oam_secondary.set_x_position(address: secondary_oam_index * 4, value: 0xFF)
            .oam_secondary.set_tile_index(address: secondary_oam_index * 4, value: 0xFF)
        }

        for sprite in (0u8..63u8).inclusive() {
            // let sprite_addr = sprite * 4u8
            // if .oam.read(address: sprite_addr) > 0xeeu8 {
            //     // Ignore any sprite below row 0xee
            //     continue
            // }


            let sprite_y = .oam.y_position(address: sprite * 4) + 1
            //eprintln("Sprite index: {}, x: {}, y: {}, scanline: {}", sprite, .oam.x_position(address: sprite * 4), .oam.y_position(address: sprite * 4), scanline)

            // If Y coordinate is in range, copy to next open slot in secondary OAM unless 8 have already been found
            mut clamp_vertical_pixel = sprite_y
            // FIXME: this doesn't handle 16 tall sprites
            if clamp_vertical_pixel > 232 {
                clamp_vertical_pixel = 232
            }
            //eprintln("Sprite within Y range - sprite_y: {}, scanline: {}, clamp: {}, eval1: {}, eval2: {}, add: {}", sprite_y, scanline, clamp_vertical_pixel, (scanline >= sprite_y), (scanline <= (clamp_vertical_pixel + sprite_height)), (clamp_vertical_pixel + sprite_height))
            // Sprite cannot exist at y0
            if ((scanline > 0) and (sprite_y > 0)) {

            if ((scanline >= sprite_y) and (scanline <= (clamp_vertical_pixel + (sprite_height - 1)))) {


                if .sprite_size_8x8 {

                    .oam_secondary.set_y_position(address: sprite_count * 4, value: (.oam.y_position(address: sprite * 4)) + 1) //TODO: nesdev docs suggest subtracting 1 here, if we do that we're in the wrong place, may merit investigation
                    .oam_secondary.set_tile_index(address: sprite_count * 4, value: .oam.tile_index(address: sprite * 4)) 
                    .oam_secondary.set_attribute(address: sprite_count * 4, value: .oam.attribute(address: sprite * 4))
                    .oam_secondary.set_x_position(address: sprite_count * 4, value: .oam.x_position(address: sprite * 4))
                    //eprintln("Adding sprite, x: {}, y: {}, tile: {}, attr: {:08b}, scanline: {}, count: {}", .oam.x_position(address: sprite * 4), .oam.y_position(address: sprite * 4), .oam.tile_index(address: sprite * 4), .oam.attribute(address: sprite * 4), scanline, sprite_count)
                    if (sprite == 0) {
                        .oam_secondary.m_sprite_zero[sprite] = true
                        //eprintln("Sprite 0")
                    }

                    // result.insert(before_index: 0, value: Sprite(
                    //     hflip: (sprite_attr & 0x40) == 0x40
                    //     mask: mask
                    //     bg_sprite: (sprite_attr & 0x20) == 0x20
                    //     sprite_x: sprite_x
                    //     sprite_zero: sprite == 0
                    // ))

                }




                //eprintln("Sprite data: {}, {}, {}, {}", .oam_secondary.y_position(address:sprite_count), .oam_secondary.tile_index(address:sprite_count), .oam_secondary.attribute(address:sprite_count), .oam_secondary.x_position(address:sprite_count))
                sprite_count += 1

                if sprite_count > 7 {
                    eprintln("Sprite overflow: {}" sprite_count )
                    // TODO: properly implement the sprite overflow bug
                    .sprite_overflow = true                    
                    break
                }
            }

            }

                // let sprite_attr = .oam.attribute(address: sprite_addr)
                // let sprite_number = .oam.tile_index(address: sprite_addr) // FIXME: second read of tile index

                // if .sprite_size_8x8 {
                //     let vflip = (sprite_attr & 0x80) == 0x80
                //     let tile_row = match vflip {
                //         false => (scanline - sprite_y)
                //         else => sprite_height - 1 - (scanline - sprite_y)
                //     }
                //     //let sprite_index = (tile_row & 0x7) | ((sprite_x & 0xf) << 4) | ((sprite_y & 0xf) << 8)
                //     // let sprite_index = .oam.tile_index(address: sprite_addr) as! u16 * 0x10 + tile_row as! u16 //FIXME: third read of tile index
                //     // let first_plane = .chr_rom_byte_at(sprite_table, sprite_index)
                //     // let second_plane = .chr_rom_byte_at(sprite_table, sprite_index + 8)

                //     // mut mask = [0u8; 8]
                //     // for i in 0..8u8 {
                //     //     mask[i] = ((first_plane >> i) & 0x1) | (((second_plane >> i & 0x1) << 1)) | ((sprite_attr & 0x3) << 2)
                //     // }



                //     // result.insert(before_index: 0, value: Sprite(
                //     //     hflip: (sprite_attr & 0x40) == 0x40
                //     //     mask: mask
                //     //     bg_sprite: (sprite_attr & 0x20) == 0x20
                //     //     sprite_x: sprite_x
                //     //     sprite_zero: sprite == 0
                //     // ))
                //     sprite_count += 1
                // } else {
                //     // 8x16
                //     let vflip = (sprite_attr & 0x80) == 0x80
                //     mut tile_row = match vflip {
                //         false => (scanline - sprite_y)
                //         else => sprite_height - 1 - (scanline - sprite_y)
                //     }
                //     //let sprite_index = (tile_row & 0x7) | ((sprite_x & 0xf) << 4) | ((sprite_y & 0xf) << 8)
                //     mut sprite_index = (sprite_number >> 1) as! u16 * 0x20 + tile_row as! u16
                //     if tile_row > 7 {
                //         // bottom half of the sprite
                //         tile_row -= 8
                //         sprite_index += 8
                //     }
                //     // let first_plane = .chr_rom_byte_at(sprite_table, sprite_index)
                //     // let second_plane = .chr_rom_byte_at(sprite_table, sprite_index + 8)

                //     // sprite tile: 2
                //     // 0000 + offset
                //     // scanline: sprite_y (tile_row)
                //     // 0x20 + 0
                //     // sprite_table[0x20 + 0]
                //     // sprite_table[0x20 + 8]

                //     // sprite_table[0x21 + 0]
                //     // sprite_table[0x21 + 8]

                //     // sprite_table[0x27 + 0]
                //     // sprite_table[0x27 + 8]

                //     // sprite_table[0x30 + 0]
                //     // sprite_table[0x30 + 8]

                //     // mut mask = [0u8; 8]
                //     // for i in 0..8u8 {
                //     //     mask[i] = ((first_plane >> i) & 0x1) | (((second_plane >> i & 0x1) << 1)) | ((sprite_attr & 0x3) << 2)
                //     // }

                //     .oam_secondary.set_y_position(address: sprite_count, value: sprite_y)
                //     .oam_secondary.set_tile_index(address: sprite_count, value: .oam.tile_index(address: sprite_addr)) //FIXME: this discounts the sprite_index shenanigans above
                //     .oam_secondary.set_attribute(address: sprite_count, value: sprite_attr)
                //     .oam_secondary.set_x_position(address: sprite_count, value: sprite_x)  

                //     // result.insert(before_index: 0, value: Sprite(
                //     //     hflip: (sprite_attr & 0x40) == 0x40
                //     //     mask: mask
                //     //     bg_sprite: (sprite_attr & 0x20) == 0x20
                //     //     sprite_x: sprite_x
                //     //     sprite_zero: sprite == 0
                //     // ))
                //     sprite_count += 1
            //     }
            // }
        }
    }


    fn render_pixel(mut this) throws {
        // BACKGROUND
        //println("Hpx: {}, Vpx: {}", horizontal_pixel, vertical_pixel)
        let visible_row = (.vertical_pixel < 240) or (.vertical_pixel == 261)

        if .horizontal_pixel == 256 and visible_row and .rendering_enabled {
            .y_increment()
        }

        if .horizontal_pixel == 257 and visible_row and .rendering_enabled {
            let abcdef = .t & 0x41f
            .v = .v & 0x7be0
            .v = .v | abcdef
        }

        if (.horizontal_pixel >= 280) and (.horizontal_pixel <= 304) and (.vertical_pixel == 261) and .rendering_enabled {
            // GHIA.BC DEF.....
            let ghiabcdef = .t & 0x7be0
            .v = .v & 0x41f
            .v = .v | ghiabcdef
        }

        guard .horizontal_pixel < 256 else {
            return
        }

        guard .vertical_pixel < 240 else {
            return
        }

        // if .horizontal_pixel == 0 {
        //     .second_oam = .find_sprites(scanline: .vertical_pixel as! u8)  
        // }

        mut bg_pixel_set = false
        mut sprite_zero_set = false

        //if .sprites_visible {
        //    sprite_zero_set |= .render_sprite_pixel(horizontal_pixel, vertical_pixel, is_behind: true)
        //}

        // FIXME: when we add support for sprites remove this
        if .background_visible and (not .left_bg_mask or .horizontal_pixel >= 8) {
            bg_pixel_set = .render_bg_pixel()
        }
        //eprintln("Render sprite - sprites visible: {}, left mask: {}, h: {} v: {}", .sprites_visible, .left_sprite_mask, .horizontal_pixel, .vertical_pixel)
        if .sprites_visible and (not .left_sprite_mask or .horizontal_pixel >= 8) {
            .render_sprite_pixel(bg_set: bg_pixel_set)
        }

        if not .background_visible and not .sprites_visible {
            let rgb = .look_up_palette_entry_bg(palette_entry: 0)
            .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb            
        }

        // if ((.horizontal_pixel % 8 == 0) or (.vertical_pixel % 8 == 0)) {
        //     let rgb = 0x00ffffffu32
        //     .video_buffer[.vertical_pixel * 256 + .horizontal_pixel] = rgb
        // }

        // if rgb.red != 0 and rgb.blue != 0 and rgb.green != 0 {
        //     println("{}, {} is {} {:0>2x}", horizontal_pixel, vertical_pixel, rgb, nametable_entry)
        // }
        // print("{:0>2x}", nametable_entry)
    }

    fn look_up_palette_entry_bg(mut this, palette_entry: u8) -> u32 {
        guard palette_entry < 16 else {
            println("ERROR: incorrect palette entry: {}", palette_entry)
            //return RGB(red: 0, green: 0, blue: 0)
            abort()
        }

        let bg_palette = .palette[palette_entry as! u64]

        return .color_palette_to_rgb(bg_palette)
    }

    fn look_up_palette_entry_sprite(mut this, palette_entry: u8) -> u32 {
        guard palette_entry < 16 else {
            println("ERROR: incorrect palette entry: {}", palette_entry)
            //return RGB(red: 0, green: 0, blue: 0)
            abort()
        }

        match palette_entry {
            0 => { return .color_palette_to_rgb(.palette[0x00]) }
            0x4 => { return .color_palette_to_rgb(.palette[0x04]) }
            0x8 => { return .color_palette_to_rgb(.palette[0x08]) }
            0xc => { return .color_palette_to_rgb(.palette[0x0c]) }
            else => { return .color_palette_to_rgb(.palette[(palette_entry as! u64)]) }
        }
    }

    fn look_up_palette_entry(mut this, palette_entry: u8) -> u32 {
        // guard palette_entry < 16 else {
        //     println("ERROR: incorrect palette entry: {}", palette_entry)
        //     //return RGB(red: 0, green: 0, blue: 0)
        //     abort()
        // }

        // eprintln("Palette lookup - value: {}", palette_entry)

        //TODO: When accessing the palette, the mirrored nametable data should be placed in the buffer.
        // This code may not handle different mirroring modes correctly.
        // It is also duplicated here and in the 0x3f00 instruction section
        .buffered_read = .read_nametable(address: ((0x3f00u16 + palette_entry as! u16) - 0x1000) as! u16)
        return .color_palette_to_rgb(palette_entry)
    }

    fn ppu_ctrl(mut this, value: u8) {

        // 7  bit  0
        // ---- ----
        // VPHB SINN
        // |||| ||||
        // |||| ||++- Base nametable address
        // |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
        // |||| |+--- VRAM address increment per CPU read/write of PPUDATA
        // |||| |     (0: add 1, going across; 1: add 32, going down)
        // |||| +---- Sprite pattern table address for 8x8 sprites
        // ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
        // |||+------ Background pattern table address (0: $0000; 1: $1000)
        // ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels – see PPU OAM#Byte 1)
        // |+-------- PPU master/slave select
        // |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
        // +--------- Generate an NMI at the start of the
        //            vertical blanking interval (0: off; 1: on)


        let gh = value & 0x3

        .t = .t & 0xf3ff
        .t = .t | ((gh as! u16) << 10)

        if (value & 0x4) == 0x4 {
            .vram_address_increment = 32
        } else {
            .vram_address_increment = 1
        }
        if (value & 0x8) == 0x8 {
            .sprite_table_address = 0x1000
        } else {
            .sprite_table_address = 0x0000
        }
        if (value & 0x10) == 0x10 {
            .background_table_address = 0x1000
        } else {
            .background_table_address = 0x0000
        }
        if (value & 0x20) == 0x20 {
            .sprite_size_8x8 = false
        } else {
            .sprite_size_8x8 = true
        }
        if (value & 0x80) == 0x80 {
            .nmi_on_vblank = true
        } else {
            .nmi_on_vblank = false
        }

        // println("base_table_address: {:0>4x} (vtick: {})", .base_table_address, .clock)
        // println("vram_address_increment: {}", .vram_address_increment)
        // println("sprite_table_address: {:0>4x}", .sprite_table_address)
        // println("background_table_address: {:0>4x}", .background_table_address)
        // println("sprite size 8x8: {}", .sprite_size_8x8)
        // println("nmi_on_vblank: {}", .nmi_on_vblank)
    }

    fn ppu_mask(mut this, value: u8) {
        // TODO: implement

        // 7  bit  0
        // ---- ----
        // BGRs bMmG
        // |||| ||||
        // |||| |||+- Greyscale (0: normal color, 1: produce a greyscale display)
        // |||| ||+-- 1: Show background in leftmost 8 pixels of screen, 0: Hide
        // |||| |+--- 1: Show sprites in leftmost 8 pixels of screen, 0: Hide
        // |||| +---- 1: Show background
        // |||+------ 1: Show sprites
        // ||+------- Emphasize red (green on PAL/Dendy)
        // |+-------- Emphasize green (red on PAL/Dendy)
        // +--------- Emphasize blue

        let PPU_GREYSCALE_MASK = 0b00000001 as! u8
        let PPU_LEFT_BACKGROUND_MASK = 0b00000010 as! u8
        let PPU_LEFT_SPRITE_MASK = 0b00000100 as! u8
        let PPU_BACKGROUND_MASK = 0b00001000 as! u8
        let PPU_SPRITE_MASK = 0b00010000 as! u8
        let PPU_RED_EMPHASIZE_MASK = 0b00100000 as! u8
        let PPU_GREEN_EMPHASIZE_MASK = 0b01000000 as! u8
        let PPU_BLUE_EMPHASIZE_MASK = 0b10000000 as! u8

        // println("PPU mask: {:0>2x}", value)

        // TODO: Bool casts aren't working in Jakt, but the below should be a 
        // quick way to set a flag once they are
        //.sprites_visible = value << 6 >>> 7 as! bool
        if (value & PPU_SPRITE_MASK) == PPU_SPRITE_MASK {
            .sprites_visible = true
        } else {
            .sprites_visible = false
        }

        if (value & PPU_BACKGROUND_MASK) == PPU_BACKGROUND_MASK {
            .background_visible = true
        } else {
            .background_visible = false
        }

        if (value & PPU_LEFT_BACKGROUND_MASK) == PPU_LEFT_BACKGROUND_MASK {
            .left_bg_mask = false
        } else {
            .left_bg_mask = true
        }

        if (value & PPU_LEFT_SPRITE_MASK) == PPU_LEFT_SPRITE_MASK {
            .left_sprite_mask = false
        } else {
            .left_sprite_mask = true
        }

        let render_bytes = (value << 3) >>> 6
        if render_bytes == 0b00 {
            .rendering_enabled = false
        } else {
            .rendering_enabled = true
        }
    }

    fn ppu_scroll(mut this, value: u16) {
        // println("PPU scroll: {:0>2x} {}", value, .scroll_toggle)

        if .w == 0 {
            let abcde = value >> 3
            .t = .t & 0xffe0
            .t = .t | abcde
            .x = value & 0x7
            .w = 1
        } else {
            let abcde = value >> 3
            let fgh = value & 0x7
            .t = .t & 0xc1f
            .t = .t | ((fgh as! u16) << 12)
            .t = .t | ((abcde as! u16) << 5)
            .w = 0
        }
    }

    fn ppu_addr(mut this, value: u8) {
        if .w == 0 {
            let cdefgh = value & 0x3f
            .t = .t & 0xff
            .t = .t | ((cdefgh as! u16) << 8)
            .w = 1
        } else {
            .t = .t & 0xff00
            .t = .t | (value as! u16)
            .v = .t
            .w = 0
        }
    }

    fn ppu_data_write(mut this, value: u8) {
        // TODO: add support for various mirroring

        // Outside of rendering, reads from or writes to $2007 will add either 1 or 32 to v depending on the VRAM increment bit set via $2000. 
        // During rendering (on the pre-render line and the visible lines 0-239, provided either background or sprite rendering is enabled), it 
        // will update v in an odd way, triggering a coarse X increment and a Y increment simultaneously (with normal wrapping behavior). 
        // Internally, this is caused by the carry inputs to various sections of v being set up for rendering, and the $2007 access triggering a 
        // "load next value" signal for all of v (when not rendering, the carry inputs are set up to linearly increment v by either 1 or 32). 
        // This behavior is not affected by the status of the increment bit. The Young Indiana Jones Chronicles uses this for some effects to 
        // adjust the Y scroll during rendering, and also Burai Fighter (U) to draw the scorebar. If the $2007 access happens to coincide with a 
        // standard VRAM address increment (either horizontal or vertical), it will presumably not double-increment the relevant counter.

        // Address range 	Size 	Description
        // $0000-$0FFF 	$1000 	Pattern table 0
        // $1000-$1FFF 	$1000 	Pattern table 1
        // $2000-$23FF 	$0400 	Nametable 0
        // $2400-$27FF 	$0400 	Nametable 1
        // $2800-$2BFF 	$0400 	Nametable 2
        // $2C00-$2FFF 	$0400 	Nametable 3
        // $3000-$3EFF 	$0F00 	Mirrors of $2000-$2EFF
        // $3F00-$3F1F 	$0020 	Palette RAM indexes
        // $3F20-$3FFF 	$00E0 	Mirrors of $3F00-$3F1F 

        // println("PPU data write rendering: {}, vblank: ", .rendering_enabled, .in_vblank)
        //  if .rendering_enabled or .in_vblank {

        mut address = .v & 0x3fff

        // println("PPU write: {:0>4x}", address)

        if address >= 0x4000 {
            println("bad ppu addr")
            abort()
        }

        if (address >= 0x0000) and (address <= 0x0fff) {
            .chr_rom_pages[.chr_rom_page_0000][address] = value
        }
        else if (address >= 0x1000) and (address <= 0x1fff) {
            .chr_rom_pages[.chr_rom_page_1000][address - 0x1000] = value            
        }
        else if (address >= 0x2000) and (address <= 0x2fff) {
            .write_nametable(address, value)
        }
        else if (address >= 0x3000) and (address <= 0x3eff) {
            // eprintln("Mirror of PPU nametable not yet supported")
            // abort()  
            .write_nametable(address: address - 0x1000, value)
        }
        else if (address >= 0x3f00) and (address <= 0x3fff) {
            let sub_address = (address - 0x3f00) % 0x20
            // FIXME: add back in mirroring
            .palette[sub_address] = value & 0x3f
        }
        match address {
            0x3f00 => { .palette[0x10] = value }
            0x3f04 => { .palette[0x14] = value }
            0x3f08 => { .palette[0x18] = value }
            0x3f0C => { .palette[0x1C] = value }
            0x3f10 => { .palette[0x00] = value }
            0x3f14 => { .palette[0x04] = value }
            0x3f18 => { .palette[0x08] = value }
            0x3f1C => { .palette[0x0C] = value }
            else => {}
        }
        .increment_v()
    }

    fn increment_v(mut this) {
        if (.background_visible or .sprites_visible) and (.vertical_pixel < 240 or .vertical_pixel == 261) {
            .coarse_x_increment()
            .y_increment()
        } else {
            .v += .vram_address_increment
        }
    }

    fn ppu_data_read(mut this) -> u8 {
        mut output = 0u8
        // println("PPU read: {:0>4x}", .v)

        let address = .v & 0x3fff

        if address <= 0x3eff {
            mut value: u8 = 0
            if address < 0x1000 {
                value = .chr_rom_byte_at(.chr_rom_page_0000, address as! u16)
            } else if address < 0x2000 {
                value = .chr_rom_byte_at(.chr_rom_page_1000, address as! u16 - 0x1000)
            } else if (address >= 0x2000) and (address <= 0x2fff){
                value = .read_nametable(address)
            }
            .increment_v()
            output = .buffered_read
            .buffered_read = value
        } else {
            .buffered_read = .read_nametable(address: ((address as! u16) - 0x1000) as! u16)
            let value = .palette[address - 0x3f00]
            .increment_v()
            output = value
        }
        return output
    }

    fn ppu_status(mut this) -> u8 {
        mut status = 0u8
        if .in_vblank {
            // println("Reading vblank status")
            status |= 0x80
        }
        if .sprite_zero_hit {
            status |= 0x40
        }

        .w = 0
        if (.vertical_pixel == 241) and (.horizontal_pixel >= 1 or .horizontal_pixel <= 3){
            .dont_vblank = true
        }
        .in_vblank = false
        return status
    }

    public fn write_ppu_addr(mut this, address: u16, value: u8) {
        // PPU registers are mirrored all the way to 3FFF, try to handle that
        let mirrored_address = (address % 0x8) + 0x2000
        match mirrored_address {
            0x2000 => .ppu_ctrl(value)
            0x2001 => .ppu_mask(value)
            0x2003 => .oam_addr_write(value) //From NESDEV wiki - most games write $00 here and use OAMDMA
            0x2004 => .oam_data_write(value)
            0x2005 => .ppu_scroll(value: value as! u16) // Write twice
            0x2006 => .ppu_addr(value) // Write twice
            0x2007 => .ppu_data_write(value)
            else => {
                eprintln("Unimplemented write to: {:0>4x}", mirrored_address)
                abort()
            }
        }
    }

    public fn oam_addr_write(mut this, value: u8) {
        //eprintln("(0x2003) OAM addr write - addr: {:x} {:08b}", .oam_addr, value)
        .oam_addr = value
    }

    public fn oam_data_read(mut this) -> u8 {
        //eprintln("(0x2004) OAM data read - addr: {:x}, data: {:08b}", .oam_addr, .oam.read(address:.oam_addr))
        let result = .oam.read(address: .oam_addr)
        //.oam_addr++
        return result
    }

    public fn oam_data_write(mut this, value: u8) {
        //eprintln("(0x2004) OAM data write - addr: {:x}, value: {:08b}", .oam_addr, value)
        .oam.write(address: .oam_addr, value: value) //TODO: passing oam_addr might be unnecessary
        if (.oam_addr == 0xFF) {
            .oam_addr = 0
        } else {
            .oam_addr++
        }
    }

    public fn read_ppu_addr(mut this, address: u16) -> u8 {
        let mirrored_address = (address % 0x8) + 0x2000
        return match mirrored_address {
            0x2002 => .ppu_status()
            0x2004 => .oam_data_read()
            0x2007 => .ppu_data_read()
            else => {
                eprintln("Unimplemented read from: {:0>4x}", mirrored_address)
                abort()
            }
        }
    }

    fn color_palette_to_rgb(mut this, anon value: u8) -> u32 {
        return .color_palette[value & 0x3f]
    }

}

fn rgb(anon red: u8, anon green: u8, anon blue: u8) -> u32 {
    return (255 << 24u32) | (blue << 16) | (green << 8) | red 
}
