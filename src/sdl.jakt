import extern c "SDL.h" {
    extern struct SDL_Renderer {}
    extern struct SDL_Window {}
    extern struct SDL_AudioDeviceID {}
    extern struct SDL_AudioSpec {}
    extern struct SDL_Texture {}
    extern struct SDL_Rect {
        public fn SDL_Rect(anon x: i32, anon y: i32, anon w: i32, anon h: i32) -> SDL_Rect
    }
    extern enum SDL_PixelType : u32 {
        SDL_PIXELTYPE_UNKNOWN,
        SDL_PIXELTYPE_INDEX1,
        SDL_PIXELTYPE_INDEX4,
        SDL_PIXELTYPE_INDEX8,
        SDL_PIXELTYPE_PACKED8,
        SDL_PIXELTYPE_PACKED16,
        SDL_PIXELTYPE_PACKED32,
        SDL_PIXELTYPE_ARRAYU8,
        SDL_PIXELTYPE_ARRAYU16,
        SDL_PIXELTYPE_ARRAYU32,
        SDL_PIXELTYPE_ARRAYF16,
        SDL_PIXELTYPE_ARRAYF32
    }
    extern enum SDL_BitmapOrder : u32 {
        SDL_BITMAPORDER_NONE,
        SDL_BITMAPORDER_4321,
        SDL_BITMAPORDER_1234
    }
    extern enum SDL_PackedOrder : u32 {
        SDL_PACKEDORDER_NONE,
        SDL_PACKEDORDER_XRGB,
        SDL_PACKEDORDER_RGBX,
        SDL_PACKEDORDER_ARGB,
        SDL_PACKEDORDER_RGBA,
        SDL_PACKEDORDER_XBGR,
        SDL_PACKEDORDER_BGRX,
        SDL_PACKEDORDER_ABGR,
        SDL_PACKEDORDER_BGRA
    }
    extern enum SDL_ArrayOrder : u32 {
        SDL_ARRAYORDER_NONE,
        SDL_ARRAYORDER_RGB,
        SDL_ARRAYORDER_BGR,
    }
    extern enum SDL_PackedLayout : u32 {
        SDL_PACKEDLAYOUT_NONE,
        SDL_PACKEDLAYOUT_332,
        SDL_PACKEDLAYOUT_4444,
        SDL_PACKEDLAYOUT_1555,
        SDL_PACKEDLAYOUT_5551,
        SDL_PACKEDLAYOUT_565,
        SDL_PACKEDLAYOUT_8888,
        SDL_PACKEDLAYOUT_2101010,
        SDL_PACKEDLAYOUT_1010102
    } 
    extern enum SDL_BlendMode : u32 {
        SDL_BLENDMODE_NONE = 0x00000000,     // < no blending dstRGBA = srcRGBA
        SDL_BLENDMODE_BLEND = 0x00000001,    // < alpha blending
                                            //   dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
                                            //   dstA = srcA + (dstA * (1-srcA)) */
        SDL_BLENDMODE_ADD = 0x00000002,      // < additive blending
                                            //   dstRGB = (srcRGB * srcA) + dstRGB
                                            //   dstA = dstA 
        SDL_BLENDMODE_MOD = 0x00000004,      // < color modulate
                                            //   dstRGB = srcRGB * dstRGB
                                            //   dstA = dstA 
        SDL_BLENDMODE_MUL = 0x00000008,      // < color multiply
                                            //   dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))
                                            //   dstA = dstA */
        SDL_BLENDMODE_INVALID = 0x7FFFFFFF
}

    extern struct SDL_PixelFormat {
        public fn SDL_PixelFormat(anon type: i32, anon order: i32, anon layout: i32, anon bpp: i32, anon depth: i32) -> raw SDL_PixelFormat
    }
    extern struct SDL_Color {
        public fn SDL_Color(anon r: u8, anon g: u8, anon b: u8, anon a: u8) -> SDL_Color
    }
    extern struct SDL_Surface {
        public fn SDL_Surface(anon surface: raw SDL_Surface) -> raw SDL_Surface
    }
    extern struct SDL_GameController {}

    extern fn SDL_SetMainReady() -> void
    extern fn SDL_Init(flags: u32) -> c_int
    extern fn SDL_CreateWindowAndRenderer(width: c_int
                                                height: c_int
                                                window_flags: u32
                                                window: raw raw SDL_Window
                                                renderer: raw raw SDL_Renderer) -> c_int
    extern fn SDL_CreateWindow(title: raw c_char, x: c_int, y: c_int, w: c_int, h: c_int, flags: u32) -> raw SDL_Window
    extern fn SDL_GetWindowSurface(window: raw SDL_Window) -> raw SDL_Surface
    extern fn SDL_SetRenderDrawColor(renderer: raw SDL_Renderer, r: u8, g: u8, b: u8, a: u8) -> c_int
    extern fn SDL_RenderClear(renderer: raw SDL_Renderer) -> c_int
    extern fn SDL_RenderPresent(renderer: raw SDL_Renderer) -> c_int
    extern fn SDL_RenderDrawPoint(renderer: raw SDL_Renderer, x: c_int, y: c_int) -> c_int
    extern fn SDL_RenderSetScale(renderer: raw SDL_Renderer, scaleX: f32, scaleY: f32) -> c_int
    extern fn SDL_DestroyRenderer(renderer: raw SDL_Renderer) -> void
    extern fn SDL_DestroyWindow(window: raw SDL_Window) -> void
    extern fn SDL_CloseAudioDevice(device: u32) -> void
    extern fn SDL_Quit() -> void
    extern fn SDL_Delay(ms: u32) -> void
    extern fn SDL_PauseAudioDevice(device: u32, mode: u32)
    extern fn SDL_QueueAudio(device: u32, sample: raw i16, sample_size: u32)
    extern fn SDL_ClearQueuedAudio(device: u32)
    extern fn SDL_LockTexture(mut texture: raw SDL_Texture, rect: raw SDL_Rect, pixels: raw raw void, pitch: raw c_int) -> c_int
    extern fn SDL_UnlockTexture(mut texture: raw SDL_Texture) -> void
    extern fn SDL_RenderCopy(mut renderer:  raw SDL_Renderer, mut texture: raw SDL_Texture, srcrect: raw SDL_Rect, dstrect: raw SDL_Rect) -> c_int
    extern fn SDL_CreateTexture(mut renderer: raw SDL_Renderer, format: u32, access: c_int, w: c_int, h: c_int) -> raw SDL_Texture
    extern fn SDL_UpdateWindowSurface(window: raw SDL_Window) -> c_int
    extern fn SDL_CreateRGBSurfaceFrom(pixels: raw void, width: c_int, height: c_int, depth: c_int, pitch: c_int, Rmask: u32, Gmask: u32, Bmask: u32, Amask: u32) -> raw SDL_Surface
    extern fn SDL_BlitScaled(source: raw SDL_Surface, srcrect: raw SDL_Rect, dest: raw SDL_Surface, destrect: raw SDL_Rect) -> c_int
    extern fn SDL_BlitSurface(source: raw SDL_Surface, srcrect: raw SDL_Rect, dest: raw SDL_Surface, destrect: raw SDL_Rect) -> c_int
    extern fn SDL_GetTicks64() -> u64
    extern fn SDL_NumJoysticks() -> c_int
    extern fn SDL_IsGameController(index: c_int) -> bool
    extern fn SDL_GameControllerOpen(index: c_int) -> raw SDL_GameController
    extern fn SDL_GameControllerClose(gamepad: raw SDL_GameController)
    extern fn SDL_GetError() -> raw c_char
    extern fn SDL_GameControllerEventState(state: c_int) -> c_int
    extern fn SDL_RenderSetVSync(mut renderer: raw SDL_Renderer, vsync: c_int) -> c_int
    extern fn SDL_CreateTextureFromSurface(mut renderer: raw SDL_Renderer, mut surface: raw SDL_Surface) -> raw SDL_Texture
    extern fn SDL_CreateRenderer(mut window: raw SDL_Window, renderer_name: raw c_char, flags: u32) -> raw SDL_Renderer
    extern fn SDL_SetSurfaceBlendMode(surface: raw SDL_Surface, blend_mode: SDL_BlendMode) -> i32
    extern fn SDL_ConvertSurface(source: raw SDL_Surface, pixel_format: raw SDL_PixelFormat, flags: u32) -> raw SDL_Surface
    extern fn SDL_ConvertSurfaceFormat(source: raw SDL_Surface, pixel_format: u32, flags: u32) -> raw SDL_Surface
    extern fn SDL_GetPixelFormatName(format: u32) -> raw c_char
    extern fn SDL_FreeSurface(surface: raw SDL_Surface)
}

enum Key {
    Up
    Down
    Left
    Right
    Return
    Z
    X
    Tab
    D
    H
    J
    L
}

enum Button {
    Up
    Down
    Left
    Right
    Start
    Select
    A
    B
}

enum SDLEvent {
    Quit
    KeyDown(key: Key)
    KeyUp(key: Key)
    ButtonDown(button: Button)
    ButtonUp(button: Button)
}

// TODO: nullptr constant anyone?
fn null<T>() -> raw T {
    unsafe {
        cpp {
            "return nullptr;"
        }
    }
    abort()
}

fn bitcast<T, U>(anon x: U) -> T {
    let impl = fn[&x](anon ptr: &mut raw T) -> T {
        unsafe {
            cpp {
                "return bit_cast<RemoveReference<decltype(*ptr)>>(x);"
            }
        }
        abort()
    }

    mut ptr = null<T>()
    return impl(&mut ptr)
}

class SDL {
    // renderer: raw SDL_Renderer
    window: raw SDL_Window
    audio_device: u32
    public surface: raw SDL_Surface
    public text_surface: raw SDL_Surface
    public outline_surface: raw SDL_Surface
    last_frame_time: u64
    gamepad: raw SDL_GameController

    public fn construct() throws -> SDL {
        return SDL(window: null<SDL_Window>(), audio_device: 0, surface: null(), text_surface: null(), outline_surface: null(), last_frame_time: 0, gamepad: null<SDL_GameController>())
    }

    public fn init_video(mut this, width: i64, height: i64) {

        let sdl_init_flags : u32 = 0x2030 // Video, Audio, Gamecontroller
        let sdl_windowpos_undefined: c_int = 0x1FFF0000
        unsafe {
            SDL_SetMainReady();
            SDL_Init(flags: sdl_init_flags);
            SDL_GameControllerEventState(state: 1);
            // SDL_CreateWindowAndRenderer(width: width as! c_int
            //                             height: height as! c_int
            //                             window_flags: 0
            //                             window: &raw .window
            //                             renderer: &raw .renderer)

            .window = SDL_CreateWindow(title: "JaktNES Monster".c_string(), x: sdl_windowpos_undefined, y: sdl_windowpos_undefined, w: width as! c_int, h: height as! c_int, flags: 0u32)
            .surface = .get_window_surface()
        }
    }

    public fn init_audio(mut this) {
        unsafe {
            cpp {
                "// opening an audio device:
                SDL_AudioSpec audio_spec;
                SDL_zero(audio_spec);
                audio_spec.freq = 44100;
                audio_spec.format = AUDIO_S16SYS;
                audio_spec.channels = 1;
                audio_spec.samples = 1024;
                audio_spec.callback = NULL;

                this->audio_device = SDL_OpenAudioDevice(
                    NULL, 0, &audio_spec, NULL, 0);"
            }
        }
    }

    public fn poll_event(this) -> SDLEvent? {
        unsafe {
            cpp {
                "SDL_Event event;
                const int has_event = SDL_PollEvent(&event);
                if (has_event && event.type == SDL_QUIT) {
                    const Optional<SDLEvent> event = typename SDLEvent::Quit();
                    return event;
                } else if (has_event && event.type == SDL_KEYDOWN) {
                    if (event.key.keysym.scancode == SDL_SCANCODE_UP) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Up());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_DOWN) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Down());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_LEFT) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Left());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_RIGHT) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Right());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_TAB) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Tab());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_RETURN) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Return());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_Z) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::Z());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_X) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::X());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_D) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::D());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_H) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::H());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_J) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::J());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_L) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyDown(typename Key::L());
                        return event;
                    }
                } else if (has_event && event.type == SDL_KEYUP) {
                    if (event.key.keysym.scancode == SDL_SCANCODE_UP) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Up());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_DOWN) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Down());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_LEFT) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Left());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_RIGHT) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Right());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_TAB) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Tab());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_RETURN) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Return());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_Z) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::Z());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_X) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::X());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_D) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::D());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_H) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::H());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_J) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::J());
                        return event;
                    } else if (event.key.keysym.scancode == SDL_SCANCODE_L) {
                        const Optional<SDLEvent> event = typename SDLEvent::KeyUp(typename Key::L());
                        return event;
                    }
                } else if (has_event && event.type == SDL_CONTROLLERBUTTONDOWN) {
                    if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_UP) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::Up());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_DOWN) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::Down());
                            return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_LEFT) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::Left());
                            return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_RIGHT) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::Right());
                            return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_A) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::A());
                            return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_B) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::B());
                            return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_START) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::Start());
                            return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_BACK) {
                            const Optional<SDLEvent> event = typename SDLEvent::ButtonDown(typename Button::Select());
                            return event;
                    }
                } else if (has_event && event.type == SDL_CONTROLLERBUTTONUP) {
                    if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_UP) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::Up());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_DOWN) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::Down());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_LEFT) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::Left());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_DPAD_RIGHT) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::Right());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_A) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::A());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_B) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::B());
                        return event;
                    } else if (event.cbutton.button == SDL_CONTROLLER_BUTTON_START) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::Start());
                        return event;
                    }  else if (event.cbutton.button ==  SDL_CONTROLLER_BUTTON_BACK) {
                        const Optional<SDLEvent> event = typename SDLEvent::ButtonUp(typename Button::Select());
                        return event;
                    }
                }"
            }
        }

        return None
    }

    public fn quit(this) {
        unsafe {
            SDL_FreeSurface (surface: .outline_surface)
            SDL_FreeSurface (surface: .text_surface)
            SDL_FreeSurface (surface: .surface)
            SDL_DestroyWindow(window: .window)
            SDL_CloseAudioDevice(device: .audio_device)
            SDL_GameControllerClose(gamepad: .gamepad)
            SDL_Quit()
        }
    }

    public fn delay(this, anon ms:u32) {
        unsafe {
            SDL_Delay(ms)
        }
    }

    public fn enable_audio(mut this) {
        unsafe {
            SDL_PauseAudioDevice(device: .audio_device, mode: 0)
        }
    }

    public fn disable_audio(mut this) {
        unsafe {
            SDL_PauseAudioDevice(device: .audio_device, mode: 1)
        }
    }

    public fn queue_audio(mut this, mut data: [i16]) {
        unsafe {
            cpp {
                "SDL_QueueAudio(this->audio_device, data.unsafe_data(), data.size() * 2);"
            }
        }
    }

    public fn clear_queued_audio(mut this) {
        unsafe {
            SDL_ClearQueuedAudio(device: .audio_device)
        }
    }
    public fn lock_texture(this, mut texture: raw SDL_Texture, rect: raw SDL_Rect, mut pixels: raw raw void, mut pitch: raw c_int) -> c_int {
        unsafe {
            return SDL_LockTexture(texture, rect, pixels, pitch)
        }
    }

    public fn unlock_texture(this, mut texture: raw SDL_Texture) -> void {
        unsafe {
            SDL_UnlockTexture(texture)
        }
    }

    public fn get_window_surface(this) -> raw SDL_Surface {
        unsafe {
            return SDL_GetWindowSurface(window: .window)
        }
    }

    public fn update_window_surface(this) ->  c_int {
        unsafe  {
            return SDL_UpdateWindowSurface(window: .window)
        }
    }

    public fn create_rgb_surface_from(this, mut pixels: raw void, width: c_int, height: c_int, depth: c_int, pitch: c_int, Rmask: u32, Gmask: u32, Bmask: u32, Amask: u32) -> raw SDL_Surface {
        unsafe  {
            return SDL_CreateRGBSurfaceFrom(pixels, width,  height,  depth,  pitch, Rmask, Gmask,  Bmask,  Amask)
        }
    }

    public fn blit_scaled(this, mut source: raw SDL_Surface, mut srcrect: raw SDL_Rect, mut dest: raw SDL_Surface, mut destrect: raw SDL_Rect) -> c_int{
        unsafe  {
            return SDL_BlitScaled(source, srcrect, dest, destrect)
        }
    }

        public fn blit_surface(this, mut source: raw SDL_Surface, mut srcrect: raw SDL_Rect, mut dest: raw SDL_Surface, mut destrect: raw SDL_Rect) -> c_int{
        unsafe  {
            return SDL_BlitSurface(source, srcrect, dest, destrect)
        }
    }

    public fn delta_time(mut this) -> u64 {
        mut this_frame_time = 0u64
        unsafe {
            this_frame_time = SDL_GetTicks64()
        }
        if .last_frame_time == 0 {
            .last_frame_time = this_frame_time
            return 0
        } else {
            let delta_time = this_frame_time - .last_frame_time
            .last_frame_time = this_frame_time
            return delta_time
        }
    }

    public fn get_controller(mut this) {
        mut joysticks: c_int = 0
        unsafe {
            joysticks = SDL_NumJoysticks()
        }
        if joysticks >= 0 {
            unsafe {
                //TODO: Make game controller detection more complex
                if (SDL_IsGameController(index: 0 as! c_int)) {
                    .gamepad = SDL_GameControllerOpen(index: 0 as! c_int)
                }
            }
        }
    }

    public fn create_texture_from_surface(this, renderer: raw SDL_Renderer, surface: raw SDL_Surface) -> raw SDL_Texture {
        unsafe {
            return SDL_CreateTextureFromSurface(renderer: renderer, surface: surface)
        }
    }

    public fn get_error(this) throws -> String {
        mut result = StringBuilder::create()
        unsafe {
            result.append_c_string(SDL_GetError())
        }
        return result.to_string()
    }

    public fn set_surface_blend_mode(this, surface: raw SDL_Surface, blend_mode: SDL_BlendMode) -> i32 {
        unsafe {
            return SDL_SetSurfaceBlendMode(surface: surface, blend_mode: blend_mode)
        }
    }

    public fn convert_surface(this, source: raw SDL_Surface, pixel_type: SDL_PixelType, pixel_order: SDL_PackedOrder, pixel_layout: SDL_PackedLayout, bits: u32, bytes: u32) -> raw SDL_Surface {

        mut format: u32 = 1 << 28
        format += pixel_type as! u32 << 24
        format += pixel_order as! u32 << 20
        format += pixel_layout as! u32 << 16
        format += bits << 8
        format += bytes

        unsafe {
            return SDL_ConvertSurfaceFormat(source: source, pixel_format: format, flags: 0) // Flags are unused but need to be set to 0
        }
    }

    public fn get_format(this, format: u32) throws -> String {
        mut name = StringBuilder::create()
        unsafe {
            name.append_c_string(SDL_GetPixelFormatName(format: format))
        }
        return name.to_string()
    }

    public fn free_surface(this, surface: raw SDL_Surface) {
        unsafe {
            SDL_FreeSurface(surface)
        }
    }

    // public fn create_renderer(this, name: String, flags: u32) -> raw SDL_Renderer {
    //     unsafe {
    //         return SDL_CreateRenderer(window: .window, renderer_name: name.c_string(), flags: 0)
    //     }
    // }
}
